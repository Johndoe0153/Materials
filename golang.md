# Go

## 프로그램을 읽는 법

```go
package main

import "fmt"

// 주석입니다

func main() {
    fmt.Println("Hello, World")
}
```

### 패키지 선언

```go
package main
```

모든 Go 프로그램은 반드시 패키지 선언으로 시작한다.

### 패키지 불러오기

```go
import "fmt"
```

### 주석

```go
//
```

### 함수 선언

```go
func main() {
    fmt.Println("Hello World")
}
```

중에서

```go
func 함수명 {

}
```

의 형식으로 이루어짐. 함수 안에

```go
fmt.Println("Hello World")
```

는 `fmt` 패키지 내의 `Println` 이란 함수에 접근한다는 의미이다. 그래서 `Hello World` 가 담긴 새 문자열을 생성해서 해당 문자열을 첫번째이자 유일한 인자로 함수를 호출한다.

## 데이터 타입

### 정수

여러 가지가 있으나 일반적으로 `int` 타입을 사용한다.

### 부동 소수점 수

이 역시 여러 가지가 있으나 일반적으로 `float64`를 사용한다.

### 문자열

`string`을 사용한다.

Back Quote(``)로 둘러 싸인 문자열은 Raw String Literal이라 부르며, 별도로 해석되지 않고 Raw String 그대로 나타난다. 또한 여러 줄의 문자열을 표현할 때 자주 사용한다.

>`\n`의 경우 줄바꿈이 아니라 그 자체로 해석

쌍따옴표(" ")로 둘러 싸인 문자열은 Interpreted String Literal 이라 불린다. 여러 줄에 걸쳐 쓸 수 없고, `\n`을 줄바꿈, `\t`를 탭으로 사용하는 이스케이프 문자열을 사용 가능하다. 여러 줄로 사용하기 위해서는 `+` 연산자로 결합하여 사용한다.

### 불린

`&&`: and  
`||`: or  
`!`: not

## 변수와 상수

>변수는 변할 수 있는 값이지만, 상수는 변할 수 없는 값

### 변수

`var` 를 키워드를 사용하여

```go
var a int // a는 변수명 int는 변수타입
```

로 선언하기도 하지만, 아래와 같이

```go
var f float32 = 11
```

변수 선언문에서 변수 초기 값을 할당하기도 한다.

또한 선언된 변수가 사용되지 않으면 에러 발생한다. 그리고 동일한 타입의 변수가 여러 개 있다면 변수들을 나열하고 마지막에 타입을 한 번만 지정한다.

또한 축약형으로

```go
x := "Hello World" // var x = "Hello World"와 동일
```

를 지원한다. 이는 타입을 따로 지정하지 않아도 컴파일러가 리터럴 값을 토대로 타입을 추론하기 때문이다.

스타일을 카멜 표기법(예: `myName`)을 따른다.

변수는 특정 함수 밖에 있는 경우에는 다른 함수에서도 접근 가능하지만, 함수 안에 있다면 다른 함수에서 접근할 수 없다.

### 상수

`const`를 키워드로 사용하여

```go
const c int = 10 // c는 상수명 int는 상수타입 10은 상수값
```

의 형식처럼 선언하나, 상수타입을 생략하더라도 자동으로 추론하는 기능이 사용되기에

```go
const c = 10
```

처럼 사용 가능하다. 또한 여러 개의 상수들을 묶어 지정할 때는 아래와 같이 작성한다.

```go
const (
    Visa = "Visa"
    Master = "MasterCard"
    Amex = "American Express"
)
```

또한 상수값을 0부터 순차적으로 부여하기 위해 `iota`라는 식별자를 사용 가능함을 아래의 코드를 통해서 알 수 있다.

```go
const (
    Apple = iota // 0
    Grape        // 1
    Orange       // 2
)
```

이 경우 `iota`가 지정된 `Apple`에는 `0`이 할당되고, 나머지 상수들을 순서대로 `1`씩 증가된 값을 부여한다고 볼 수가 있다.

## for 문

Go의 유일한 반복문

```go
package main
 
import "fmt"
 
func main() {
    i := 1
    for i <= 10 {
        fmt.Println(i)
        i = i + 1
    }
}
```

와 같은 형식을 띌 수 있음. `for 초기값; 조건식; 증감`의 형식을 따르며, 아래의 두 항목을 참고사항으로 가진다고 말할 수 있을 것이다.

- 초기값, 증감식 생략: 타 언어의 `while` 처럼 사용
- 모두 생략: 무한루프, 빠져 나오기 위해 Ctrl+C 사용

`for` 루프 내에서 빠져 나오기 위해 `break` 문을 사용한다. 그러나 만약 중간에 나머지를 실행하지 않고 `for` 루프 시작점으로 가려면 `continue` 문을 사용한다.

## if 문

```go
if k == 1 {  //같은 라인
    println("One")
}
```

와 같은 형식으로 작성하며, 조건 블럭의 중괄호를 `if 문`과 같은 라인에 두어야 에러가 나지 않는다. 또한 조건식은 **반드시 `Boolean` 식으로** 표현되어야 한다.

`else if` 문은 `if` 조건문이 거짓일 때 다시 다른 if 조건식을 검사할 때 사용하며, `else` 문은 이전의 `if` 문들이 모두 거짓일 때 실행한다.

## switch 문

여러 값을 비교해야하는 경우 혹은 다수의 조건식을 체크해야 하는 경우 사용된다. `switch` 문 뒤에 하나의 변수(또는 expression)를 지정하고, `case` 문에 해당 변수가 가질 수 있는 값들을 지정하여, 각 경우에 다른 문장 블럭들을 실행한다. 여러 개의 `case` 값이 있다면 `,(콤마)`를 써서 나열한다.

```go
package main
 
func main() {
    var name string
    var category = 1
 
    switch category {
    case 1:
        name = "Paper Book"
    case 2:
        name = "eBook"
    case 3, 4:
        name = "Blog"
    default:
        name = "Other"
    }
    println(name)
     
    // Expression을 사용한 경우
    switch x := category << 2; x - 1 {
        //...
    }   
}
```

값이 일치하는 케이스가 없을 경우 실행될 기본 케이스인 `default`도 있다. 또한 Go는 컴파일러가 자동으로 `break`를 자동으로 각 `case` 문 블럭 마지막에 추가해서 생략 가능하다. 그래서 계속 밑의 문장들을 실행하고자 할 때 `fallthrough` 문을 명시한다.

## 함수

`func` 키워드로 정의된다. `func` 뒤에 함수명을 적고 괄호 () 안에 그 함수를 전달하는 매개변수( == parameter, 함수에 투입되는 변수를 의미)들을 적는다.

매개변수는 0개 이상 사용 가능하며, 각 매개변수는 매개변수 뒤에 `int`, `string` 같은 매개변수의 타입을 적어서 정의한다. 함수의 리턴 타입은 매개변수 괄호 () 뒤에 적게 된다.

```go
package main
func main() {
    msg := "Hello"
    say(msg)
}
 
func say(msg string) { //msg가 매개변수이며 
    println(msg)
}
```

위의 코드가 그 예시이며, 이러한 방식을 `Pass By Value` 라고 부른다. 매개변수  `msg`의 값이 `say()` 함수 내에서 변경된다 하더라도 호출함수 `main()`에서의 `msg` 변수는 변함이 없다.

반면 또 다른 방식도 있다.

```go
package main
func main() {
    msg := "Hello"
    say(&msg)
    println(msg) //변경된 메시지 출력
}
 
func say(msg *string) {
    println(*msg)
    *msg = "Changed" //메시지 변경
}
```

위 코드를 살펴보면, `msg` 변수 앞에 `&` 부호를 붙였는데 이는 `msg` 변수의 주소를 표시하는 것이다. 이러한 용법을 `포인터`라 부른다.

>포인터에 대해: 변수 파트에서 **"변수는 특정 함수 밖에 있는 경우에는 다른 함수에서도 접근 가능하지만, 함수 안에 있다면 다른 함수에서 접근할 수 없다."**
라고 했었다. 이 중에서 `"함수 안에 있다면 다른 함수에서 접근 할 수 없다"`라는 말처럼, 다른 함수에서는 또 다른 함수 내의 변수에 접근을 할 수가 없게 된다. 그러나 `포인터`를 사용한다면 포인터를 사용한 `변수의 메모리 영역의 주소(쉽게 말해 위치)`에 접근하여 값을 변경할 수 있게 된다.

`포인터`를 사용하면 함수에 `msg` 변수의 값을 복사하지 않아도 `msg` 변수의 주소를 전달하게 된다. 그렇게 되면 피호출 함수 `say()`는 `*string`과 같이 매개변수가 `포인터`임을 표시하고 이때 `say` 함수의 `msg`는 문자열이 아니라 문자열이 갖는 메모리 영역의 주소를 갖게 된다. 그래서 `msg` 주소에 데이터를 쓰기 위해서는 `*msg = "어쩌고"`와 같이 앞에 `*`를 붙이는 데 이를 